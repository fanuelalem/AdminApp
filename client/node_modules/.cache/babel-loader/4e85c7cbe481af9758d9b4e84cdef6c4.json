{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst {\n  Readable\n} = require('stream'); // Parameters for safe file name parsing.\n\n\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\nconst MAX_EXTENSION_LENGTH = 3; // Parameters to generate unique temporary file names:\n\nconst TEMP_COUNTER_MAX = 65536;\nconst TEMP_PREFIX = 'tmp';\nlet tempCounter = 0;\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\n\nconst debugLog = (options, msg) => {\n  const opts = options || {};\n  if (!opts.debug) return false;\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\n\n  return true;\n};\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\n\n\nconst getTempFilename = (prefix = TEMP_PREFIX) => {\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\n  return `${prefix}-${tempCounter}-${Date.now()}`;\n};\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\n\n\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true : false;\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\n\n\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * @returns {Function}\r\n */\n\n\nconst promiseCallback = (resolve, reject) => {\n  return err => err ? errorFunc(resolve, reject)(err) : resolve();\n};\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\n\n\nconst buildOptions = function () {\n  const result = {};\n  [...arguments].forEach(options => {\n    if (!options || typeof options !== 'object') return;\n    Object.keys(options).forEach(i => result[i] = options[i]);\n  });\n  return result;\n};\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\n\n\nconst buildFields = (instance, field, value) => {\n  // Do nothing if value is not set.\n  if (value === null || value === undefined) return instance;\n  instance = instance || {}; // Non-array fields\n\n  if (!instance[field]) {\n    instance[field] = value;\n    return instance;\n  } // Array fields  \n\n\n  if (instance[field] instanceof Array) {\n    instance[field].push(value);\n  } else {\n    instance[field] = [instance[field], value];\n  }\n\n  return instance;\n};\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\n\n\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\n  // Check upload options were set.\n  if (!fileUploadOptions) return false;\n  if (!fileUploadOptions.createParentPath) return false; // Check whether folder for the file exists.\n\n  if (!filePath) return false;\n  const parentPath = path.dirname(filePath); // Create folder if it doesn't exist.\n\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, {\n    recursive: true\n  }); // Checks folder again and return a results.\n\n  return fs.existsSync(parentPath);\n};\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\n\n\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\n\n\nconst copyFile = (src, dst, callback) => {\n  // cbCalled flag and runCb helps to run cb only once.\n  let cbCalled = false;\n\n  let runCb = err => {\n    if (cbCalled) return;\n    cbCalled = true;\n    callback(err);\n  }; // Create read stream\n\n\n  let readable = fs.createReadStream(src);\n  readable.on('error', runCb); // Create write stream\n\n  let writable = fs.createWriteStream(dst);\n  writable.on('error', err => {\n    readable.destroy();\n    runCb(err);\n  });\n  writable.on('close', () => runCb()); // Copy file via piping streams.\n\n  readable.pipe(writable);\n};\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\n\n\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => err ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback)) : callback());\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\n\n\nconst saveBufferToFile = (buffer, filePath, callback) => {\n  if (!Buffer.isBuffer(buffer)) {\n    return callback(new Error('buffer variable should be type of Buffer!'));\n  } // Setup readable stream from buffer.\n\n\n  let streamData = buffer;\n  let readStream = Readable();\n\n  readStream._read = () => {\n    readStream.push(streamData);\n    streamData = null;\n  }; // Setup file system writable stream.\n\n\n  let fstream = fs.createWriteStream(filePath);\n  fstream.on('error', err => callback(err));\n  fstream.on('close', () => callback()); // Copy file via piping streams.\n\n  readStream.pipe(fstream);\n};\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\n\n\nconst uriDecodeFileName = (opts, fileName) => {\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\n};\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\n\n\nconst parseFileNameExtension = (preserveExtension, fileName) => {\n  const preserveExtensionLengh = parseInt(preserveExtension);\n  const result = {\n    name: fileName,\n    extension: ''\n  };\n  if (!preserveExtension && preserveExtensionLengh !== 0) return result; // Define maximum extension length\n\n  const maxExtLength = isNaN(preserveExtensionLengh) ? MAX_EXTENSION_LENGTH : Math.abs(preserveExtensionLengh);\n  const nameParts = fileName.split('.');\n  if (nameParts.length < 2) return result;\n  let extension = nameParts.pop();\n\n  if (extension.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength);\n    extension = extension.substr(-maxExtLength);\n  }\n\n  result.extension = maxExtLength ? extension : '';\n  result.name = nameParts.join('.');\n  return result;\n};\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\n\n\nconst parseFileName = (opts, fileName) => {\n  // Check fileName argument\n  if (!fileName || typeof fileName !== 'string') return getTempFilename(); // Cut off file name if it's lenght more then 255.\n\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255); // Decode file name if uriDecodeFileNames option set true.\n\n  parsedName = uriDecodeFileName(opts, parsedName); // Stop parsing file name if safeFileNames options hasn't been set.\n\n  if (!opts.safeFileNames) return parsedName; // Set regular expression for the file name.\n\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX; // Parse file name extension.\n\n  let {\n    name,\n    extension\n  } = parseFileNameExtension(opts.preserveExtension, parsedName);\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\n  return name.replace(nameRegex, '').concat(extension);\n};\n\nmodule.exports = {\n  isFunc,\n  debugLog,\n  copyFile,\n  // For testing purpose.\n  moveFile,\n  errorFunc,\n  deleteFile,\n  // For testing purpose.\n  buildFields,\n  buildOptions,\n  parseFileName,\n  getTempFilename,\n  promiseCallback,\n  checkAndMakeDir,\n  saveBufferToFile,\n  uriDecodeFileName\n};","map":null,"metadata":{},"sourceType":"script"}