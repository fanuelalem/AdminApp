{"ast":null,"code":"const Busboy = require('busboy');\n\nconst UploadTimer = require('./uploadtimer');\n\nconst fileFactory = require('./fileFactory');\n\nconst memHandler = require('./memHandler');\n\nconst tempFileHandler = require('./tempFileHandler');\n\nconst processNested = require('./processNested');\n\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\n\nmodule.exports = (options, req, res, next) => {\n  req.files = null; // Build busboy options and init busboy instance.\n\n  const busboyOptions = buildOptions(options, {\n    headers: req.headers\n  });\n  const busboy = new Busboy(busboyOptions); // Close connection with specified reason and http code, default: 400 Bad Request.\n\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, {\n      Connection: 'close'\n    });\n    res.end(reason || 'Bad Request');\n  }; // Build multipart req.body fields\n\n\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val)); // Build req.files fields\n\n  busboy.on('file', (field, file, name, encoding, mime) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const filename = parseFileName(options, name); // Define methods and handlers for upload process.\n\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles ? tempFileHandler(options, field, filename) // Upload into temporary file.\n    : memHandler(options, field, filename); // Upload into RAM.\n    // Define upload timer.\n\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume(); // After destroy an error event will be emitted and file clean up will be done.\n\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`); // Reset upload timer in case of file limit reached.\n\n      uploadTimer.clear(); // Run a user defined limit handler if it has been set.\n\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next); // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        closeConnection(413, options.responseOnLimit);\n        cleanup();\n      }\n    });\n    file.on('data', data => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n\n      dataHandler(data); // Handle new piece of data.\n    });\n    file.on('end', () => {\n      const size = getFileSize(); // Debug logging for file upload ending.\n\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`); // Reset upload timer in case of end event.\n\n      uploadTimer.clear(); // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n\n      req[waitFlushProperty].push(getWritePromise());\n    });\n    file.on('error', err => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n\n      debugLog(options, err);\n      cleanup();\n      next();\n    }); // Debug logging for a new file upload.\n\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`); // Set new upload timeout for a new file.\n\n    uploadTimer.set();\n  });\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty]).then(() => {\n      delete req[waitFlushProperty];\n      next();\n    }).catch(err => {\n      delete req[waitFlushProperty];\n      debugLog(options, `Error while waiting files flush: ${err}`);\n      next(err);\n    });\n  });\n  busboy.on('error', err => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n  req.pipe(busboy);\n};","map":null,"metadata":{},"sourceType":"script"}