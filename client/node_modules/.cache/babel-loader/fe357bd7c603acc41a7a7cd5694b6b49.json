{"ast":null,"code":"const mongoose = require('mongoose');\n\nconst {\n  isEmail,\n  isLength\n} = require('validator');\n\nconst bcrypt = require('bcryptjs');\n\nconst {\n  Schema,\n  model\n} = mongoose;\nconst UserSchema = new Schema({\n  email: {\n    type: String,\n    unique: true,\n    validate: [isEmail, 'Please enter a valid email address'],\n    required: [true, 'You must provide an email address']\n  },\n  password: {\n    type: String,\n    required: [true, 'You must provide a password'],\n    validate: [value => isLength(value, {\n      min: 6\n    }), 'Your password must be at least 6 characters long']\n  },\n  dateCreated: {\n    type: Date,\n    default: Date.now()\n  },\n  myStocks: [{\n    type: Schema.Types.ObjectId,\n    ref: 'Stock'\n  }]\n});\n\nUserSchema.methods.toJSON = function () {\n  var obj = this.toObject();\n  delete obj.password;\n  return obj;\n};\n\nUserSchema.methods.comparePassword = async function (candidatePassword) {\n  const user = this;\n\n  try {\n    const isMatch = await bcrypt.compare(candidatePassword, user.password);\n    return Promise.resolve(isMatch);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nUserSchema.pre('save', async function (next) {\n  // gets access to the user model that is currently being saved\n  const user = this;\n\n  if (user.isModified('password')) {\n    try {\n      const salt = await bcrypt.genSalt();\n      const hash = await bcrypt.hash(user.password, salt); // overwrite the plain text password with our hash\n\n      user.password = hash; // Finally call save\n\n      next();\n    } catch (e) {\n      // Call save with an error\n      next(e);\n    }\n  }\n\n  next();\n});\nmodule.exports = model('User', UserSchema);","map":null,"metadata":{},"sourceType":"script"}