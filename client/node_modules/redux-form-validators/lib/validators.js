"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _messages = _interopRequireDefault(require("./messages"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var DEFAULT_OPTIONS = {
  memoize: true,
  allowBlank: false,
  urlProtocols: ['http', 'https'],
  dateFormat: 'yyyy-mm-dd',
  // ISO
  dateYmd: 'ymd',
  accept: ['1', 'true'],
  caseSensitive: true // confirmation, inclusion, exclusion

};
var Validators = {
  formatMessage: formatMessage,
  formatSize: formatSize,
  defaultOptions: DEFAULT_OPTIONS,
  messages: _messages["default"],
  pluralRules: {
    0: 'zero',
    1: 'one'
  }
};
var _default = Validators;
exports["default"] = _default;

function formatSize(size, unit) {
  return size + ' ' + unit;
}

function formatMessage(msg) {
  if (msg.props) {
    msg = msg.props;
  }

  var text = msg.defaultMessage || msg.id ||
  /* istanbul ignore next */
  '';
  var rules = Validators.pluralRules;
  return !msg.values ? text : parseMsg(text, function (part) {
    var parts = part.split(',');
    var count = msg.values[parts[0]]; // {value} OR {count, number}

    if (parts.length <= 2) {
      return count == null ? '' : '' + count;
    } // plural


    var plural = parts.slice(2).join(',').trim();
    var info = {};
    var result = parseMsg(plural, null, rules[+count] || 'other', info);
    return info.found ? result : parseMsg(plural, null, 'other', {});
  });
}

function parseMsg(msg, func, pattern, info) {
  var start = msg.indexOf('{');
  if (start < 0) return pattern ? '' : msg;
  var index = start;
  var count = 1;
  var len = msg.length;

  while (count > 0 && index < len) {
    ++index;

    if (msg.charAt(index) === '{') {
      ++count;
    }

    if (msg.charAt(index) === '}') {
      --count;
    }
  }

  if (pattern) {
    if (pattern === msg.slice(0, start).trim()) {
      info.found = true;
      return msg.slice(start + 1, index).trim();
    }

    return parseMsg(msg.slice(index + 1), null, pattern, info);
  } // func gets all '{.*}' parts
  // e.g:
  // - {count}
  // - {count, plural, one {1 thing} other {many things}}
  // - ...


  return msg.slice(0, start) + parseMsg(func(msg.slice(start + 1, index).trim()), func) + parseMsg(msg.slice(index + 1), func);
}